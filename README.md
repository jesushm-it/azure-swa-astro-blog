# azure-swa-astro-blog-with-terraform
## Description

The code in this repository is meant to deploy resources to host a static website generated by Astro on Azure Web Apps with a custom domain. You will need the following to deploy successfully:

* Terraform installed locally
* Azure CLI installed locally
* Astro installed locally for testing
* Azure subscription
* Registered domain name for website

## Table of Contents
Below is the outline of the overarching procedure we'll adhere to:

- [Installation](#installation)
  1. [Fork and clone the Repository](#fork-and-clone-the-repository)
  1. [Prepare the infrastructure](#prepare-the-infrastructure)
  1. [Storage State Data](#storage-state-data)
  1. [Prepare your Terraform variable values](#prepare-your-terraform-variable-values) 
  1. [Deploy the Infrastructure](#deploy)
  1. [Verify your domain](#verify-your-domain)
  1. [Set up your domain nameservers](#set-up-your-dns)
  1. [Set Up Your Repository](#set-up-your-repository)
  1. [GitHub Actions Workflow](#github-actions-workflow)
  
- [Usage](#usage)
  1. [Personal Blog](#personal-blog)
  1. [Why Choose Azure Static Web Apps?](#why-choose-azure-static-web-apps)
  1. [Why Static Sites?](#why-static-sites)
  1. [Why Choose Astro?](#why-choose-astro)
  1. [Blog website](#blog-website)

- [License](#license)

# Installation

## Fork and clone the Repository
Your new website will reside in a GitHub repository and be published via GitHub Actions. 
To get started, fork this repository to your account by clicking the Fork button.

After forking, clone your repository to your local workstation. This is where we'll run our commands from.

* git clone <repository_url>

## Prepare the infrastructure
To deploy Azure resources via Terraform, choose where to store state data. If it's a one-time deployment, use the local backend and delete afterwards. Otherwise, for ongoing management, utilize Azure for state storage. Next, follow steps to create a storage account and container via Azure CLI for Terraform state, and adjust configuration accordingly.

## Storage State Data
We'll set up an Azure storage account and container for our state data, then modify the backend block in terraform.tf to utilize this storage account.

```bash
# Bash commands. Navigate to the infrastructure directory.
cd infrastructure
```
```bash
# Store website name in a variable for naming, no capitals or punctuation
website_name=YOUR_WEBSITE_DOMAIN_NAME # e.g. mywebsitecom
region=AZURE_REGION_TO_USE # e.g. centralus
```

```bash
## Log in with Azure CLI and select a subscription
az login
az account set -s SUBSCRIPTION_NAME # e.g "Azure for Students"
```
```bash
## Create an resource group
az group create -n "${website_name}tfdata" -l $region
```
```bash
## Create a storage account
az storage account create --name "${website_name}tfdata" --resource-group "${website_name}tfdata" \
  --location $region --sku Standard_LRS
```
```bash
## Create a storage account container
az storage container create -n tfdata --account-name "${website_name}tfdata" \
  --resource-group "${website_name}tfdata" 
```
```bash
## Set up backend config file
cat << EOF > backend-config.txt
resource_group_name="${website_name}tfdata"
storage_account_name="${website_name}tfdata"
container_name="tfdata"

EOF
```

## Prepare your Terraform variable values

In the `infrastructure` directory is a file named `terraform.tfvars.example`, rename it to `terraform.tfvars` and fill out the values in the file. For my example, let's assume I want to publish my blog called "sub.mydomain.com" in the Central US region. I would set the following values:

```terraform
region = "centralus"
website_name = "sub.mydomain.com"
custom_domain_name = "mydomain.com"
```
Terraform sets up a DNS Zone for sub.mydomain.com, adding two records: a TXT record for validation under 'blog' with a token from Azure Static Web Apps, and an Alias record directing 'blog' to the app. Azure Static Web Apps supports TXT or CNAME validation, but CNAME doesn't work with apex domains like 10bitpodcast.com, so TXT is preferred.

## Deploy

Let's launch our web app! First, navigate to the `infrastructure` directory and run `terraform init`. Use the command for local state data or the one for Azure Storage, depending on your setup.

```bash
# Run this command if you're using local state data
terraform init
```

```bash
# Run this command if you're using Azure Storage for state data
terraform init -backend-config=backend-config.txt
```

Now you can simply run `terraform apply` to stand up your resources:

```bash
terraform apply -auto-approve
```

The output you receive will include the Azure nameservers and API token for your web app. It should look something like this:

```bash
api_token = "123456789012345678901234567890123456789012345678901234567890"
name_servers = toset([
  "ns1-09.azure-dns.com.",
  "ns2-09.azure-dns.net.",
  "ns3-09.azure-dns.org.",
  "ns4-09.azure-dns.info.",
])
```
You will use these values in the following sections.

## Verify your domain

To use a custom domain name with Azure Static Web Apps, you need to verify that you own the domain. We've already created the validation TXT record in the Azure DNS zone, but Static Web Apps can't find it until we update the name servers for domain.


## Set up your DNS

To configure this part, follow your domain registrar's instructions. Specify Azure DNS as your domain's manager and input the four custom name servers provided by Terraform. Note:

* Remove any trailing periods from the Azure name servers.
* The name servers may differ from those listed here.
* Allow time for internet propagation after making changes. Grab a coffee and relax! â˜•

## Set Up Your Repository

Utilize the API token from Terraform output to enable GitHub Actions for deployment. In your GitHub repository, navigate to Settings -> Secrets -> Actions, and add a new secret named `AZURE_STATIC_WEB_APPS_API_TOKEN`, assigning it the value of the api_token Terraform output. This enables GitHub Actions to deploy your Static Web App seamlessly.

## GitHub Actions Workflow
The GitHub Actions required for deployment are specified in azure-static-web-apps.yml within .github/workflows. The typical workflow for publishing updates to your site is as follows:

1. Make updates, create new posts, add images, etc., on a new local branch.
1. Test locally to ensure everything displays correctly.
1. Push your branch to GitHub.
1. Open a Pull Request to merge your branch into `main`.

The Pull Request triggers GitHub Actions to deploy a temporary site on Azure, with the temporary site URL provided as a comment.

1. Review the temporary site.
1. If changes are needed, update locally, push to GitHub, and refresh the temporary site.
1. If everything looks good, merge the Pull Request into `main`.

Merging initiates GitHub Actions to delete the temporary site and deploy the updates to your main site.

That's it! Repeat this workflow whenever you need to make changes.

# Usage

## Personal Blog
Managing your own domain and blog ensures ownership and freedom. Relying solely on third-party platforms risks losing control over your content and being subject to their decisions."

## Why Choose Azure Static Web Apps?

Opting for Azure SWA offers numerous benefits beyond basic website deployment. Its generous free tier, coupled with features like global hosting, API functions, streamlined build and deployment, and seamless staging environments, make it a compelling choice.

+Info:

pricing: https://azure.microsoft.com/en-us/pricing/details/app-service/static/#pricing

Suported Frameworks & libraries:

https://learn.microsoft.com/en-us/azure/static-web-apps/front-end-frameworks

## Why Static Sites?
Static sites render quickly without requiring server-side compute. They're deployable anywhere that can handle HTML, including platforms like WordPress.

## Why Choose Astro?
Astro excels as the go-to web framework for content-centric sites like blogs, marketing, and e-commerce. Renowned for its innovative frontend architecture, Astro minimizes JavaScript complexity and overhead, ensuring lightning-fast loading times and optimal SEO performance. Here's why Astro stands out:

* Server-first Approach: Accelerates website performance by prioritizing server-side HTML rendering.
* Built for Speed: Impossible to create a sluggish website with Astro's default settings.
* User-Friendly: No expertise required; Astro simplifies website development for everyone.
* Developer-Centric: Equips developers with the necessary resources for success.

Additionally, Astro's Islands architecture enhances frontend performance by eliminating monolithic JavaScript patterns and automatically removing non-essential JavaScript from pages.

For more information on Astro's Islands architecture, visit: https://docs.astro.build/en/concepts/islands/

## Blog website

In the `website` directory, you'll find a basic astro website using the blog theme. Customize themes, add static content, and preview your site locally before deploying it to Azure.

Explore other themes at astro.build/themes/. Remove the current theme from the website folder and add your chosen theme.

Deploy the website as-is and customize it later. Refer to the blog template guide.

To test your website changes, first install dependencies:

``` 
npm install 
```
Start the local dev server at localhost:4321 with:
```
npm run dev
```
View your running dev instance at localhost:4321.

Explore the blog theme details [Here](https://github.com/withastro/astro/tree/main/examples/blog)

# License
This project is licensed under the [MIT License](LICENSE).  
Credits: Original Author Ned Bellavance

updates from hugo version:
* Deprecated arguments.
* Supported regions.
* Readme content.
* Astro website files.
* GitHub Actions configuration.
